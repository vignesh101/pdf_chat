<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Document Chat</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <div class="app">

      <!-- Main Chat Area -->
      <main class="main-content">
        <header class="chat-header">
          <h1>Document Chat</h1>
        </header>

        {% if not client_ready %}
        <div class="alert warn" role="alert" style="margin: 12px 16px 0 16px;">
          OpenAI client is not configured. Set OPENAI_API_KEY or update config.toml, then restart the app.
        </div>
        {% endif %}

        <div class="sub-tabs" style="display:flex; gap:8px; padding: 0 16px 8px 16px; align-items:center;">
          <button id="tab-chat" class="tab-btn active">Document Chat</button>
          <button id="tab-sidebar" class="tab-btn">Settings</button>
        </div>

        

        <div class="chat-container">
          <div id="messages-docs" class="messages"></div>
          <div id="sidebar-tab" class="sidebar-tab" style="display:none; padding: 16px;">
            <div class="sidebar-tab-header" style="display:flex; justify-content:flex-end; gap:8px; margin-bottom:8px;">
              <button class="new-chat-btn" id="new-chat" title="Start new chat">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
              </button>
            </div>
            <section class="uploader">
              <h3>Upload Documents</h3>
              <form id="upload-form">
                <div class="dropzone" id="dropzone">
                  <input type="file" id="file" name="file" multiple />
                  <div class="dz-instructions">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                      <polyline points="7,10 12,15 17,10"/>
                      <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    <span>Drop files here or click to browse</span>
                  </div>
                </div>
                <button type="submit" class="upload-btn">Upload Files</button>
                <div id="upload-status" class="upload-status"></div>
              </form>
            </section>

            <section class="chat-history">
              <div class="history-header">
                <h3>Chat History</h3>
                <button id="btn-clear" type="button" class="clear-btn" title="Clear chat history">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6m3 0V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
                  </svg>
                </button>
              </div>
              <div id="history-list" class="history-list"></div>
              <div id="history-meta" class="history-meta"></div>
            </section>

            <section class="status-panel">
              <h3>Status</h3>
              <div class="status-row">
                <span id="status-client" class="badge">OpenAI: …</span>
              </div>
              <div class="status-row" style="margin-top:6px;">
                <span id="status-index" class="badge">Index: …</span>
              </div>
              <div class="status-row" style="margin-top:6px;">
                <span id="status-files" class="badge neutral">Files: …</span>
              </div>
              <div class="status-actions">
                <button id="btn-rebuild" type="button" class="action-btn">Rebuild Index</button>
                <button id="btn-cancel-rebuild" type="button" class="action-btn warn" style="display:none;">Cancel</button>
                <button id="btn-clear-index" type="button" class="action-btn danger">Clear Index</button>
                <button id="btn-clear-all" type="button" class="action-btn danger">Clear All Data</button>
              </div>
              <div class="progress" id="rebuild-progress-wrap">
                <div id="rebuild-progress" class="progress-bar" style="width:0%"></div>
              </div>
              <div id="status-note" class="status-note"></div>
            </section>

            <section class="recent-files">
              <h3>Upload History</h3>
              <div id="recent-files-list" class="recent-files-list"></div>
            </section>
          </div>
          <div class="chat-input-container">
            <form id="chat-form" class="chat-form">
              <div class="input-wrapper">
                <textarea id="message" rows="1" placeholder="Message..." autocomplete="off"></textarea>
                <button id="btn-send" type="submit" aria-label="Send message">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"/>
                    <polygon points="22,2 15,22 11,13 2,9 22,2"/>
                  </svg>
                </button>
              </div>
            </form>
          </div>
        </div>
      </main>
    </div>

    

    <script>
      const $ = (sel) => document.querySelector(sel);
      let activeTab = 'chat';
      const messagesDocsEl = $("#messages-docs");
      const sidebarTabEl = $("#sidebar-tab");
      const uploadForm = $("#upload-form");
      const chatForm = $("#chat-form");
      const uploadStatus = $("#upload-status");
      const dropzone = $("#dropzone");
      const btnClear = $('#btn-clear');
      const historyList = $('#history-list');
      const historyMeta = $('#history-meta');
      const btnSend = $('#btn-send');
      const statusClient = $('#status-client');
      const statusIndex = $('#status-index');
      const statusFiles = $('#status-files');
      const statusNote = $('#status-note');
      const btnRebuild = $('#btn-rebuild');
      const btnCancelRebuild = $('#btn-cancel-rebuild');
      const btnClearIndex = $('#btn-clear-index');
      const btnClearAll = $('#btn-clear-all');
      const progressWrap = $('#rebuild-progress-wrap');
      const progressBar = $('#rebuild-progress');
      const recentFilesList = $('#recent-files-list');
      const newChatBtn = $('#new-chat');

      function escapeHtml(str) {
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
        return (str || '').replace(/[&<>"']/g, (ch) => map[ch]);
      }

      // Basic URL guard for http(s) links
      function isHttpUrl(u) {
        try { return /^https?:\/\//i.test((u || '').trim()); } catch (_) { return false; }
      }

      // Enhanced Markdown -> HTML rendering for readable output
      function mdToHtml(text) {
        if (!text) return '';
        const esc = escapeHtml;

        function sanitizeUrl(raw) {
          try {
            const url = (raw || '').trim();
            if (/^https?:\/\//i.test(url)) {
              return url.replace(/\"/g, '&quot;');
            }
            return '';
          } catch (_) { return ''; }
        }

        function renderInline(raw) {
          // Escape first, then apply markdown replacements on the escaped text.
          let t = esc(raw || '');
          const placeholders = [];
          // Protect code spans first
          t = t.replace(/`([^`]+)`/g, (_, code) => {
            const idx = placeholders.length;
            placeholders.push(`<code class=\"inline-code\">${code}</code>`);
            return `\u0001CODE_${idx}\u0002`;
          });
          // Images ![alt](url)
          t = t.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_, alt, url) => {
            const safe = sanitizeUrl(url);
            const escAlt = (alt || '').replace(/\"/g, '&quot;');
            if (!safe) return `[image: ${escAlt}]`;
            return `<img src=\"${safe}\" alt=\"${escAlt}\" />`;
          });
          // Links [text](url)
          t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, url) => {
            const safe = sanitizeUrl(url);
            if (!safe) return label;
            return `<a href=\"${safe}\" target=\"_blank\" rel=\"noopener\">${label}</a>`;
          });
          // Autolink bare URLs
          t = t.replace(/(https?:\/\/[\w.-]+(?:\/[\w\-._~:/?#[\]@!$&'()*+,;=.]+)?)/g, '<a href=\"$1\" target=\"_blank\" rel=\"noopener\">$1</a>');
          // Bold, then italics (simple rules)
          t = t.replace(/(\*\*|__)(.+?)\1/g, '<strong>$2</strong>');
          t = t.replace(/(^|\W)\*(?!\*)([^\*]+)\*(?=\W|$)/g, '$1<em>$2</em>');
          t = t.replace(/(^|\W)_(?!_)([^_]+)_(?=\W|$)/g, '$1<em>$2</em>');
          // Restore code span placeholders
          t = t.replace(/\u0001CODE_(\d+)\u0002/g, (_, i) => placeholders[Number(i)] || '');
          return t;
        }

        // Normalize newlines
        const lines = (text + '').replace(/\r\n?/g, '\n').split('\n');
        let i = 0;
        let out = [];
        let paraBuf = [];
        let inFence = false;
        let fenceLang = 'text';
        let fenceLines = [];

        function flushPara() {
          if (paraBuf.length === 0) return;
          const s = paraBuf.join(' ').trim();
          if (s) out.push(`<p>${renderInline(s)}</p>`);
          paraBuf = [];
        }

        function parseTableRow(line) {
          // Trim optional leading/trailing pipes and split
          let s = (line || '').trim();
          if (s.startsWith('|')) s = s.slice(1);
          if (s.endsWith('|')) s = s.slice(0, -1);
          return s.split('|').map(c => c.trim());
        }

        function parseTableSep(line) {
          // Return alignment array if valid separator row, else null
          let s = (line || '').trim();
          if (s.startsWith('|')) s = s.slice(1);
          if (s.endsWith('|')) s = s.slice(0, -1);
          const parts = s.split('|').map(c => c.trim());
          if (parts.length === 0) return null;
          const aligns = [];
          for (const p of parts) {
            if (!/^:?-{3,}:?$/.test(p)) return null;
            const left = p.startsWith(':');
            const right = p.endsWith(':');
            aligns.push(right && left ? 'center' : right ? 'right' : left ? 'left' : 'left');
          }
          return aligns;
        }

        while (i < lines.length) {
          let line = lines[i];

          // Fenced code blocks ```lang ...```
          const fence = line.match(/^\s*```([a-zA-Z0-9_-]*)\s*$/);
          if (fence) {
            if (!inFence) {
              inFence = true;
              fenceLang = fence[1] || 'text';
              fenceLines = [];
            } else {
              // Closing fence
              out.push(`<pre class=\"code-block\"><code class=\"lang-${esc(fenceLang)}\">${esc(fenceLines.join('\n'))}</code></pre>`);
              inFence = false;
              fenceLang = 'text';
              fenceLines = [];
            }
            i++;
            continue;
          }
          if (inFence) { fenceLines.push(line); i++; continue; }

          // Horizontal rule
          if (/^\s{0,3}(\*\s?\*\s?\*|-{3,}|_{3,})\s*$/.test(line)) {
            flushPara();
            out.push('<hr/>' );
            i++;
            continue;
          }

          // Headings # .. ######
          const h = line.match(/^(#{1,6})\s+(.+)$/);
          if (h) {
            flushPara();
            const level = h[1].length;
            out.push(`<h${level}>${renderInline(h[2].trim())}</h${level}>`);
            i++;
            continue;
          }

          // Blockquote
          if (/^\s*>\s?/.test(line)) {
            flushPara();
            const bq = [];
            while (i < lines.length && /^\s*>\s?/.test(lines[i])) {
              bq.push(lines[i].replace(/^\s*>\s?/, ''));
              i++;
            }
            const inner = mdToHtml(bq.join('\n'));
            out.push(`<blockquote>${inner}</blockquote>`);
            continue;
          }

          // Unordered list
          if (/^\s*[-+*]\s+/.test(line)) {
            flushPara();
            const items = [];
            while (i < lines.length && /^\s*[-+*]\s+/.test(lines[i])) {
              const m = lines[i].match(/^\s*[-+*]\s+(.+)$/);
              items.push(m ? m[1] : lines[i]);
              i++;
            }
            out.push('<ul>' + items.map(it => `<li>${renderInline(it)}</li>`).join('') + '</ul>');
            continue;
          }

          // Ordered list
          if (/^\s*\d+\.\s+/.test(line)) {
            flushPara();
            const items = [];
            while (i < lines.length && /^\s*\d+\.\s+/.test(lines[i])) {
              const m = lines[i].match(/^\s*\d+\.\s+(.+)$/);
              items.push(m ? m[1] : lines[i]);
              i++;
            }
            out.push('<ol>' + items.map(it => `<li>${renderInline(it)}</li>`).join('') + '</ol>');
            continue;
          }

          // GitHub-Flavored Markdown tables
          if (line.includes('|') && i + 1 < lines.length) {
            const headerCells = parseTableRow(line);
            const aligns = parseTableSep(lines[i + 1]);
            if (aligns && headerCells.length) {
              flushPara();
              i += 2; // consume header + separator
              const rows = [];
              while (i < lines.length) {
                const ln = lines[i];
                if (!ln || !ln.includes('|')) break;
                const rowCells = parseTableRow(ln);
                if (rowCells.length === 1 && rowCells[0] === '') break;
                rows.push(rowCells);
                i++;
              }
              const cols = Math.max(headerCells.length, aligns.length);
              const ths = headerCells.map((c, idx) => {
                const al = aligns[Math.min(idx, aligns.length - 1)] || 'left';
                return `<th style=\"text-align:${al}\">${renderInline(c)}</th>`;
              }).join('');
              const tb = rows.map(r => {
                const tds = [];
                for (let k = 0; k < Math.max(cols, r.length); k++) {
                  const c = r[k] || '';
                  const al = aligns[Math.min(k, aligns.length - 1)] || 'left';
                  tds.push(`<td style=\"text-align:${al}\">${renderInline(c)}</td>`);
                }
                return `<tr>${tds.join('')}</tr>`;
              }).join('');
              out.push(`<table><thead><tr>${ths}</tr></thead><tbody>${tb}</tbody></table>`);
              continue;
            }
          }

          // Blank line -> paragraph break
          if (/^\s*$/.test(line)) { flushPara(); i++; continue; }

          // Otherwise, accumulate paragraph text
          paraBuf.push(line);
          i++;
        }

        // Flush any remaining paragraph
        flushPara();

        // If a code fence never closed, flush it as-is
        if (inFence) {
          out.push(`<pre class=\"code-block\"><code class=\"lang-${esc(fenceLang)}\">${esc(fenceLines.join('\n'))}</code></pre>`);
        }

        return out.join('');
      }

      // Lightweight client-side syntax highlighter (no CDN)
      function highlightCode(src, lang) {
        const esc = escapeHtml;
        const l = (lang || '').toLowerCase();

        function span(cls, s) { return '<span class="tok ' + cls + '">' + esc(s) + '</span>'; }

        function runRegex(s, regex, classify) {
          let out = '';
          let last = 0;
          let m;
          regex.lastIndex = 0;
          while ((m = regex.exec(s))) {
            if (m.index > last) out += esc(s.slice(last, m.index));
            out += classify(m);
            last = regex.lastIndex;
          }
          if (last < s.length) out += esc(s.slice(last));
          return out;
        }

        function highlightJSON(s) {
          const re = /"(?:\\.|[^"\\])*"|-?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b(?:true|false)\b|\bnull\b|[{}\[\]:,]/g;
          return runRegex(s, re, (m) => {
            const tok = m[0];
            if (tok[0] === '"') return span('string', tok);
            if (tok === 'true' || tok === 'false') return span('boolean', tok);
            if (tok === 'null') return span('null', tok);
            if (/^-?\d/.test(tok)) return span('number', tok);
            return span('punc', tok);
          });
        }

        function highlightCLike(s, keywords, opts) {
          const kw = keywords.map(k => k.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
          const re = new RegExp(
            [
              opts.blockComments ? '/\\*[\\s\\S]*?\\*/' : null,
              opts.lineComments ? '//[^\n]*' : null,
              '"(?:\\.|[^"\\])*"',
              "'(?:\\.|[^'\\])*'",
              opts.backticks ? '`(?:\\.|[^`\\])*`' : null,
              '-?\\b\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\b',
              '(?:^|\\b)(' + kw + ')(?:\\b)'
            ].filter(Boolean).join('|'),
            'g'
          );
          return runRegex(s, re, (m) => {
            const tok = m[0];
            if (tok.startsWith('/*') || tok.startsWith('//')) return span('comment', tok);
            if (tok[0] === '"' || tok[0] === '\'' || tok[0] === '`') return span('string', tok);
            if (/^-?\d/.test(tok)) return span('number', tok);
            const kwMatch = m[1];
            if (kwMatch) return span('keyword', kwMatch);
            return esc(tok);
          });
        }

        function highlightPython(s) {
          const keywords = [
            'False','class','finally','is','return','None','continue','for','lambda','try','True','def','from','nonlocal','while','and','del','global','not','with','as','elif','if','or','yield','assert','else','import','pass','break','except','in','raise'
          ];
          const kw = keywords.map(k => k.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
          const re = new RegExp(
            [
              '"""[\\s\\S]*?"""',
              "'''[\\s\\S]*?'''",
              '#[^\n]*',
              '"(?:\\.|[^"\\])*"',
              "'(?:\\.|[^'\\])*'",
              '-?\\b\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\b',
              '(?:^|\\b)(' + kw + ')(?:\\b)'
            ].join('|'), 'g'
          );
          return runRegex(s, re, (m) => {
            const tok = m[0];
            if (tok.startsWith('"""') || tok.startsWith("'''")) return span('string', tok);
            if (tok.startsWith('#')) return span('comment', tok);
            if (tok[0] === '"' || tok[0] === '\'') return span('string', tok);
            if (/^-?\d/.test(tok)) return span('number', tok);
            if (m[1]) return span('keyword', m[1]);
            return esc(tok);
          });
        }

        function highlightBash(s) {
          const keywords = ['if','then','fi','elif','else','for','in','do','done','case','esac','while','until','function','select'];
          const kw = keywords.map(k => k.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
          const re = new RegExp(
            [
              '#[^\n]*',
              '"(?:\\.|[^"\\])*"',
              "'(?:\\.|[^'\\])*'",
              '\\$(?:[A-Za-z_][A-Za-z0-9_]*|\\{[^}]+\\})',
              '-?\\b\\d+(?:\\.\\d+)?\\b',
              '(?:^|\\b)(' + kw + ')(?:\\b)'
            ].join('|'), 'g'
          );
          return runRegex(s, re, (m) => {
            const tok = m[0];
            if (tok.startsWith('#')) return span('comment', tok);
            if (tok[0] === '"' || tok[0] === '\'') return span('string', tok);
            if (tok[0] === '$') return span('variable', tok);
            if (/^-?\d/.test(tok)) return span('number', tok);
            if (m[1]) return span('keyword', m[1]);
            return esc(tok);
          });
        }

        function highlightYAML(s) {
          const lines = s.split(/\n/);
          const boolNull = /\b(?:true|false|null|~)\b/i;
          const num = /-?\b\d+(?:\.\d+)?\b/;
          return lines.map(line => {
            // Comments
            const hash = line.indexOf('#');
            let before = hash >= 0 ? line.slice(0, hash) : line;
            const comment = hash >= 0 ? line.slice(hash) : '';
            // Key detection (at line start, ignoring list dash)
            const m = before.match(/^\s*-?\s*([A-Za-z_][\w-]*)\s*:\s?(.*)$/);
            let rendered;
            if (m) {
              const key = m[1];
              const rest = m[2] || '';
              rendered = span('key', key) + span('punc', ':') + ' ' + renderScalars(rest);
            } else {
              rendered = renderScalars(before);
            }
            if (comment) rendered += span('comment', comment);
            return rendered;
          }).join('\n');

          function renderScalars(str) {
            return runRegex(str, /"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\b(?:true|false|null|~)\b|-?\b\d+(?:\.\d+)?\b/g, (m) => {
              const tok = m[0];
              if (tok[0] === '"' || tok[0] === '\'') return span('string', tok);
              if (boolNull.test(tok)) return /null|~/i.test(tok) ? span('null', tok) : span('boolean', tok);
              if (num.test(tok)) return span('number', tok);
              return esc(tok);
            });
          }
        }

        switch (l) {
          case 'json': return highlightJSON(src);
          case 'js': case 'jsx': case 'ts': case 'tsx': case 'javascript': case 'typescript':
            return highlightCLike(src,
              ['break','case','catch','class','const','continue','debugger','default','delete','do','else','export','extends','finally','for','function','if','import','in','instanceof','let','new','return','super','switch','this','throw','try','typeof','var','void','while','with','yield','await','enum','implements','interface','package','private','protected','public','static'],
              { lineComments: true, blockComments: true, backticks: true }
            );
          case 'py': case 'python':
            return highlightPython(src);
          case 'bash': case 'sh': case 'shell':
            return highlightBash(src);
          case 'yaml': case 'yml':
            return highlightYAML(src);
          default:
            // Fallback: JSON detection for code starting with { or [
            if (/^\s*[\[{]/.test(src)) return highlightJSON(src);
            return esc(src);
        }
      }

      function applyHighlight(root) {
        try {
          const codes = root.querySelectorAll('pre.code-block > code');
          codes.forEach((code) => {
            const cls = code.getAttribute('class') || '';
            const m = cls.match(/lang-([a-z0-9_-]+)/i);
            const lang = m ? m[1] : 'text';
            const raw = code.textContent || '';
            const html = highlightCode(raw, lang);
            code.innerHTML = html;
            if (code.parentElement) code.parentElement.setAttribute('data-lang', lang);
          });
        } catch (e) {
          // non-fatal
        }
      }

      function getMessagesEl() {
        return messagesDocsEl;
      }

      function messageElFor(m) {
        const wrap = document.createElement('div');
        wrap.className = 'msg ' + (m.role === 'user' ? 'user' : 'assistant');
        const row = document.createElement('div');
        row.className = 'msg-row';
        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.textContent = m.role === 'user' ? 'You' : 'AI';
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        const body = document.createElement('div');
        body.className = 'body';
        body.innerHTML = mdToHtml(m.text || '');
        applyHighlight(body);
        const tools = document.createElement('div');
        tools.className = 'tools';
        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.className = 'tool copy';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try { await navigator.clipboard.writeText(m.text || ''); copyBtn.textContent = 'Copied!'; setTimeout(()=> copyBtn.textContent = 'Copy', 1200); } catch (_) {}
        });
        tools.appendChild(copyBtn);
        bubble.appendChild(body);
        bubble.appendChild(tools);
        // Show web search context if present (Web chat)
        if (m.role !== 'user' && m.search) {
          const details = document.createElement('details');
          details.className = 'sources';
          const summary = document.createElement('summary');
          const engine = (m.search.engine || 'Web');
          const usedCount = Array.isArray(m.search.used_urls) ? m.search.used_urls.length : 0;
          summary.textContent = `Search (${engine}: ${usedCount})`;
          details.appendChild(summary);
          // Diagnostics/warning
          try {
            const status = m.search.status || {};
            const note = (typeof status.note === 'string' && status.note) ? status.note : null;
            const ok = (typeof status.ok === 'boolean') ? status.ok : true;
            if (usedCount === 0 || !ok || note) {
              const warn = document.createElement('div');
              warn.className = 'note warn';
              warn.textContent = note ? `Web search: ${note}` : 'Web search returned no URLs. Paste a URL or check proxy/SSL settings.';
              details.appendChild(warn);
            }
          } catch (_) {}
          const list = document.createElement('ol');
          list.className = 'sources-list';
          const titleMap = new Map();
          try {
            (m.search.results || []).forEach(r => { if (r && r.url) titleMap.set(r.url, r.title || ''); });
          } catch (_) {}
          (m.search.used_urls || []).forEach((url) => {
            const li = document.createElement('li');
            li.className = 'source-item';
            const meta = document.createElement('div');
            meta.className = 'meta';
            if (isHttpUrl(url)) {
              const a = document.createElement('a');
              a.href = url;
              a.target = '_blank';
              a.rel = 'noopener';
              a.textContent = titleMap.get(url) || url;
              meta.appendChild(a);
            } else {
              meta.textContent = url || 'unknown';
            }
            li.appendChild(meta);
            list.appendChild(li);
          });
          if (usedCount > 0) details.appendChild(list);
          bubble.appendChild(details);
        }

        // Show sources panel with clickable links
        if (m.role !== 'user' && Array.isArray(m.sources) && m.sources.length) {
          const details = document.createElement('details');
          details.className = 'sources';
          const summary = document.createElement('summary');
          summary.textContent = `Sources (${m.sources.length})`;
          details.appendChild(summary);
          const list = document.createElement('ol');
          list.className = 'sources-list';
          m.sources.forEach((s) => {
            const li = document.createElement('li');
            li.className = 'source-item';
            const meta = document.createElement('div');
            meta.className = 'meta';
            const file = s.file_name ? s.file_name : (s.file_id || 'local');
            const scoreText = ` • score: ${typeof s.score === 'number' ? s.score.toFixed(3) : s.score}`;
            if (s.file_id && isHttpUrl(s.file_id)) {
              const a = document.createElement('a');
              a.href = s.file_id;
              a.target = '_blank';
              a.rel = 'noopener';
              a.textContent = file;
              meta.appendChild(a);
              meta.appendChild(document.createTextNode(scoreText));
            } else {
              meta.textContent = `${file}${scoreText}`;
            }
            const preview = document.createElement('div');
            preview.className = 'preview';
            preview.textContent = (s.text || '').slice(0, 500);
            li.appendChild(meta);
            li.appendChild(preview);
            list.appendChild(li);
          });
          details.appendChild(list);
          bubble.appendChild(details);
        }
        row.appendChild(avatar);
        row.appendChild(bubble);
        wrap.appendChild(row);
        return wrap;
      }

      function appendMessageObj(m, intoEl) {
        const el = messageElFor(m);
        const target = intoEl || getMessagesEl();
        target.appendChild(el);
        target.scrollTop = target.scrollHeight;
      }

      function renderHistoryList(messages) {
        if (!Array.isArray(messages)) messages = [];
        historyList.innerHTML = '';

        if (messages.length === 0) {
          historyList.innerHTML = '<div class="empty-history">No messages yet</div>';
          historyMeta.textContent = '';
          return;
        }

        messages.forEach((m, index) => {
          const item = document.createElement('div');
          item.className = 'history-item ' + (m.role || '');

          const content = document.createElement('div');
          content.className = 'history-content';
          content.textContent = (m.text || '').slice(0, 100) + (m.text && m.text.length > 100 ? '...' : '');

          const timestamp = document.createElement('div');
          timestamp.className = 'history-timestamp';
          timestamp.textContent = m.role === 'user' ? 'You' : 'Assistant';

          item.appendChild(content);
          item.appendChild(timestamp);
          historyList.appendChild(item);
        });

        const count = messages.length || 0;
        historyMeta.textContent = `${count} message${count === 1 ? '' : 's'}`;
      }

      // Simple tab layout; no sidebar toggle

      async function refreshMessagesDocs() {
        try {
          const res = await fetch('/messages');
          const data = await res.json();
          if (!data.ok) return;
          messagesDocsEl.innerHTML = '';
          (data.messages || []).forEach(m => appendMessageObj(m, messagesDocsEl));
          renderHistoryList(data.messages || []);
          refreshStatus();
        } catch (e) { console.error(e); }
      }

      // No other chat modes in simplified UI

      async function refreshCurrentMessages() {
        if (activeTab === 'chat') return refreshMessagesDocs();
        return;
      }

      let rebuildPoller = null;
      async function refreshStatus() {
        try {
          const res = await fetch('/status');
          const data = await res.json();
          if (!data.ok) return;
          const clientReady = !!data.client_ready;
          const idx = data.index || {};
          const idxReady = !!idx.index_ready;
          const chunks = typeof idx.chunks_count === 'number' ? idx.chunks_count : 0;
          const files = typeof idx.files_count === 'number' ? idx.files_count : 0;
          statusClient.textContent = clientReady ? 'OpenAI: Ready' : 'OpenAI: Not configured';
          statusClient.className = 'badge ' + (clientReady ? 'ok' : 'err');
          statusIndex.textContent = idxReady ? `Index: Ready • ${chunks} chunk${chunks===1?'':'s'}` : `Index: Not initialized`;
          statusIndex.className = 'badge ' + (idxReady && chunks>0 ? 'ok' : 'err');
          statusFiles.textContent = `Files: ${files}`;

          // Progress UI
          const rb = (idx && idx.rebuild) || {};
          const inProg = !!rb.in_progress;
          const pct = Math.max(0, Math.min(100, Number(rb.progress || 0)));
          progressWrap.style.display = inProg ? 'block' : 'none';
          progressBar.style.width = pct + '%';
          btnCancelRebuild.style.display = inProg ? 'inline-block' : 'none';
          if (inProg) {
            statusNote.textContent = `Rebuilding... ${pct.toFixed(0)}%`;
            if (!rebuildPoller) {
              rebuildPoller = setInterval(refreshStatus, 1000);
            }
          } else {
            if (rebuildPoller) { clearInterval(rebuildPoller); rebuildPoller = null; }
            if (rb.error) {
              statusNote.textContent = 'Rebuild failed: ' + rb.error;
            } else if (rb.cancelled) {
              statusNote.textContent = 'Rebuild cancelled.';
            } else if (pct >= 100 && chunks > 0) {
              statusNote.textContent = 'Index ready.';
            }
          }

          // Refresh upload history separately
          refreshFiles();
        } catch (e) {
          // ignore
        }
      }

      function fmtTime(ts) {
        try { if (!ts) return ''; const d = new Date(ts * 1000); return d.toLocaleString(); } catch (_) { return ''; }
      }

      async function refreshFiles() {
        try {
          const res = await fetch('/files');
          const data = await res.json();
          recentFilesList.innerHTML = '';
          if (!data.ok || !Array.isArray(data.files) || data.files.length === 0) {
            recentFilesList.innerHTML = '<div class="empty-history">No files yet</div>';
            return;
          }
          data.files.forEach((f) => {
            const row = document.createElement('div');
            row.className = 'recent-file';
            const left = document.createElement('div');
            left.className = 'rf-left';
            left.innerHTML = `<div class=\"rf-name\">${escapeHtml(f.name || f.file_id)}</div><div class=\"rf-meta\">${fmtTime(f.created_at)} • ${f.chunks} chunk${(f.chunks===1)?'':'s'}</div>`;
            const right = document.createElement('div');
            right.className = 'rf-actions';
            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'action-btn danger';
            del.textContent = 'Remove';
            del.addEventListener('click', async () => {
              if (!confirm(`Remove \"${f.name}\" and its chunks from index?`)) return;
              del.disabled = true;
              try {
                const r = await fetch('/files/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ file_id: f.file_id }) });
                const dj = await r.json();
                if (dj.ok) { refreshStatus(); refreshFiles(); }
                else { alert('Failed to remove: ' + (dj.error || 'unknown error')); }
              } catch (e) { alert('Request failed while removing.'); }
              finally { del.disabled = false; }
            });
            right.appendChild(del);
            row.appendChild(left);
            row.appendChild(right);
            recentFilesList.appendChild(row);
          });
        } catch (e) {
          recentFilesList.innerHTML = '<div class="empty-history">Failed to load files</div>';
        }
      }

      // Drag & drop uploads
      let droppedFiles = [];
      const dropEvents = ['dragenter','dragover','dragleave','drop'];
      dropEvents.forEach(evt => dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); }));
      ;['dragenter','dragover'].forEach(evt => dropzone.addEventListener(evt, () => dropzone.classList.add('dragging')));
      ;['dragleave','drop'].forEach(evt => dropzone.addEventListener(evt, () => dropzone.classList.remove('dragging')));
      dropzone.addEventListener('drop', (e) => {
        const files = Array.from(e.dataTransfer.files || []);
        if (files.length) {
          droppedFiles = droppedFiles.concat(files);
          uploadStatus.textContent = `${droppedFiles.length} file(s) ready`;
        }
      });
      $('#file').addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length) {
          droppedFiles = droppedFiles.concat(files);
          uploadStatus.textContent = `${droppedFiles.length} file(s) ready`;
          e.target.value = '';
        }
      });

      uploadForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData();
        const toSend = droppedFiles;
        if (!toSend.length) {
          uploadStatus.textContent = 'No files selected.';
          return;
        }
        toSend.forEach(f => fd.append('file', f, f.name));
        uploadStatus.textContent = 'Uploading...';
        try {
          const res = await fetch('/upload', { method: 'POST', body: fd });
          const data = await res.json();
          if (data.ok) {
            uploadStatus.textContent = `Uploaded ${data.file_ids.length} file(s)`;
            droppedFiles = [];
            refreshStatus();
            refreshFiles();
          } else {
            uploadStatus.textContent = `Error: ${data.error || 'upload failed'}`;
          }
        } catch (err) {
          uploadStatus.textContent = 'Upload failed.';
        }
      });

      chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (activeTab !== 'chat') { return; }
        const input = $("#message");
        const text = input.value.trim();
        if (!text) return;
        // Append the user's message immediately
        appendMessageObj({ role: 'user', text });
        input.value = '';
        btnSend.disabled = true;
        // Create a real assistant bubble we can live-update during streaming
        const assistantLive = messageElFor({ role: 'assistant', text: 'Thinking…' });
        const assistantBody = assistantLive.querySelector('.body');
        const targetEl = getMessagesEl();
        targetEl.appendChild(assistantLive);
        targetEl.scrollTop = targetEl.scrollHeight;
        try {
          const endpoint = '/chat_stream';
          const payload = { message: text };
          const res = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (res.ok && res.body) {
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let acc = '';
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value, { stream: true });
              acc += chunk;
              // Render as markdown-ish HTML as it streams
              assistantBody.innerHTML = mdToHtml(acc);
              applyHighlight(assistantBody);
              targetEl.scrollTop = targetEl.scrollHeight;
            }
            // After stream ends, persist the conversation on the server
            let committed = false;
            try {
              const saveRes = await fetch('/chat/commit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question: text, answer: acc })
              });
              const saveDj = await saveRes.json();
              if (!saveDj.ok) {
                // Keep the streamed text visible and surface the error subtly
                console.error('Commit failed:', saveDj.error);
              } else {
                committed = true;
              }
            } catch (e) {
              console.error('Commit request failed', e);
            }
            // Only refresh from server if commit succeeded; otherwise keep live bubbles
            if (committed) {
              await refreshCurrentMessages();
            }
          } else {
            const body = { message: text };
            const r = await fetch('/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            const dj = await r.json();
            if (dj.ok) { await refreshCurrentMessages(); }
            else { assistantBody.textContent = 'Error: ' + (dj.error || 'failed'); }
          }
        } catch (err) {
          assistantBody.textContent = 'Request failed.';
        } finally {
          btnSend.disabled = false;
        }
      });

      // Shift+Enter for newline, Enter to send; auto-resize
      const msgInput = $("#message");
      msgInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          chatForm.requestSubmit();
        }
      });
      msgInput.addEventListener('input', () => {
        msgInput.style.height = 'auto';
        msgInput.style.height = Math.min(200, msgInput.scrollHeight) + 'px';
      });

      // No sidebar element; tabs control visibility

      btnClear.addEventListener('click', async () => {
        const sure = confirm('Clear chat history for this session?');
        if (!sure) return;
        try {
          const res = await fetch('/clear', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            await refreshCurrentMessages();
          } else {
            alert('Failed to clear: ' + (data.error || 'unknown error'));
          }
        } catch (e) {
          alert('Request failed while clearing.');
        }
      });

      newChatBtn.addEventListener('click', async () => {
        try {
          const res = await fetch('/clear', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            await refreshCurrentMessages();
          } else {
            alert('Failed to start new chat: ' + (data.error || 'unknown error'));
          }
        } catch (e) {
          alert('Request failed while starting new chat.');
        }
      });

      // Tabs behavior
      const tabChat = $('#tab-chat');
      const tabSidebar = $('#tab-sidebar');
      function setActiveTab(tab) {
        activeTab = tab;
        if (tab === 'chat') {
          tabChat.classList.add('active');
          tabSidebar.classList.remove('active');
          messagesDocsEl.style.display = '';
          if (sidebarTabEl) sidebarTabEl.style.display = 'none';
          $('.chat-input-container').style.display = '';
        } else {
          tabChat.classList.remove('active');
          tabSidebar.classList.add('active');
          messagesDocsEl.style.display = 'none';
          if (sidebarTabEl) sidebarTabEl.style.display = '';
          $('.chat-input-container').style.display = 'none';
        }
        refreshCurrentMessages();
      }
      tabChat.addEventListener('click', () => setActiveTab('chat'));
      tabSidebar.addEventListener('click', () => setActiveTab('sidebar'));

      // Initial load
      refreshMessagesDocs();
      refreshStatus();
      refreshFiles();

      btnRebuild.addEventListener('click', async () => {
        btnRebuild.disabled = true;
        statusNote.textContent = 'Rebuilding index...';
        try {
          const res = await fetch('/index/rebuild_async', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            progressWrap.style.display = 'block';
            statusNote.textContent = 'Rebuilding...';
            refreshStatus(); // start polling via refresh
          } else {
            statusNote.textContent = 'Rebuild failed: ' + (data.error || 'unknown error');
          }
        } catch (e) {
          statusNote.textContent = 'Rebuild request failed.';
        } finally {
          btnRebuild.disabled = false;
        }
      });

      btnClearIndex.addEventListener('click', async () => {
        const sure = confirm('Clear FAISS index? (Metadata kept; you can rebuild later)');
        if (!sure) return;
        btnClearIndex.disabled = true;
        statusNote.textContent = 'Clearing index...';
        try {
          const res = await fetch('/index/clear', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            statusNote.textContent = 'Index cleared.';
            refreshStatus();
          } else {
            statusNote.textContent = 'Clear failed: ' + (data.error || 'unknown error');
          }
        } catch (e) {
          statusNote.textContent = 'Clear request failed.';
        } finally {
          btnClearIndex.disabled = false;
        }
      });

      btnCancelRebuild.addEventListener('click', async () => {
        btnCancelRebuild.disabled = true;
        statusNote.textContent = 'Cancelling...';
        try {
          const res = await fetch('/index/rebuild_cancel', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            // polling loop will detect finish and show cancelled
            refreshStatus();
          } else {
            statusNote.textContent = 'Cancel failed: ' + (data.error || 'unknown error');
          }
        } catch (e) {
          statusNote.textContent = 'Cancel request failed.';
        } finally {
          btnCancelRebuild.disabled = false;
        }
      });

      btnClearAll.addEventListener('click', async () => {
        const sure = confirm('Clear ALL data? This deletes both the index and metadata. This cannot be undone.');
        if (!sure) return;
        btnClearAll.disabled = true;
        statusNote.textContent = 'Clearing all data...';
        try {
          const res = await fetch('/index/clear_all', { method: 'POST' });
          const data = await res.json();
          if (data.ok) {
            statusNote.textContent = 'All data cleared.';
            progressWrap.style.display = 'none';
            refreshStatus();
          } else {
            statusNote.textContent = 'Clear all failed: ' + (data.error || 'unknown error');
          }
        } catch (e) {
          statusNote.textContent = 'Clear all request failed.';
        } finally {
          btnClearAll.disabled = false;
        }
      });

      // Simplified: no external caches (web/conf/octane) controls

      // No voice tab in this simplified UI
    </script>
  </body>
  </html>
